## 1. C++用户空间内存分区有哪些？作用是什么？

**C++ 内存分区：栈、堆、全局/静态存储区、常量存储区、代码区。**

**栈**：存放函数的局部变量、函数参数、返回地址等，由编译器自动分配和释放。

**堆**：动态申请的内存空间，就是由 malloc 分配的内存块，由程序员控制它的分配和释放，如果程序执行结束还没    有释放，操作系统会自动回收。

**全局区/静态存储区**：存放全局变量和静态变量，程序运行结束操作系统自动释放。

**常量存储区**：存放的是常量，不允许修改，程序运行结束自动释放。

**代码区**：存放代码，不允许修改，但可以执行。编译后的二进制文件存放在这里。

## 2. C++ static关键字有哪些作用？

**全局静态变量**：位于静态存储区，在整个程序执行期间一直存在，未经初始化的全局静态变量会自动初始化为0，全局静态变量在声明之前他的文件之外是不可见的，准确地说是从定义之处开始，到文件结尾。

**静态局部变量**：也是位于静态存储区，未经初始化的全局静态变量会被初始化为0，局部作用域，当定义他的语句或者函数块结束的时候，作用域结束。但是当局部静态变量离开作用域后，并没有销毁，而是仍然驻留在内存中，只是我们不能对他进行访问，直至该函数再次调用，并且值不变。

**静态函数**：在函数返回类型前面加上static，函数就定义成静态函数。函数的定义和声明在默认的情况下都是extern的，但静态函数只是在声明的文件中可见，不能被其他文件所用。函数的实现使用static修饰，那么这个函数只可在本cpp内使用，不会同其他cpp中的同名函数引起冲突；

**类的静态成员**：在类中，静态成员可以实现多个对象之间的数据共享，并且使用静态数据成员还不会破坏隐藏的原则，即保证了安全性。因此，静态成员是类的所有对象中共享的成员，而不是某个对象的成员。对多个对象来说，静态数据成员只存储一处，供所有对象共用。**可以不创建对象，通过类名直接访问。**可通过<类名>::<静态成员函数名>(<参数表>)访问。

**类的静态函数**：静态成员函数和静态数据成员一样，它们都属于类的静态成员，它们都不是对象成员。因此，对静态成员的引用不需要用对象名。在静态成员函数的实现中不能直接引用类中说明的非静态成员，可以引用类中说明的静态成员。可通过<类名>::<静态成员>访问。

## 3. 指针常量和常量指针的区别？

**指针常量**：指针本身是常量。该指针只能指向某个常量，不可再指向其他常量。（指针地址不可变，值可变)

(注：指针常量在定义时要赋初值）

```c++
int a = 0，b = 0;
int* const p = &a;
*p = 1; //正确，可以修改值
*p = &b; //错误，不可改变地址
```

**常量指针**：指向常量的指针。该指针指向一个常量，常量的值不可变，不可以通过该指针修改其值，但是该指针可以指向其他常量。（指针地址可以变，值不能变）

```c++
int a = 0，b = 0;
const int *p = &a;
*p = 1; //错误，不可修改常量值
*p = &b; //正确，可以指向另一个常量
```

**区分记忆**：如果关键字 const 出现在 * 号左边，表示被指物是常量，侧重点是常量，值不可变；如果出现在 * 号右边，表示指针自身是常量，侧重点是指针，地址不可变；如果出现在 * 号两边，表示被指物和指针都是常量，地址和值都不可变。（简化记忆：const 与 * 号，谁在左边就以谁为侧重点）

## 4. 动态库和静态库的区别？

**区别**：**静态库**在程序编译时会被链接到代码中，程序运行时将不再需要静态库。后缀是lib。

​		    **动态库**在程序编译并不会链接到代码中，而是在程序运行时被载入，动态库又被称为动态链接库，英文简称DLL，DLL是包含可以由多个程序使用的代码和数据的库，DLL是不可执行文件。

**静态库**：

*优点：*

1.静态库被打包到应用程序中，所以加载速度更快（静态库是在链接时直接将代码加载到内存中，而动态库在加载时需要去寻找动态库位置，所以相对更慢一些）

2.发布时无需提供静态库，移植方便（直接将代码链接成可执行文件发给使用者，因此发布时无需提供静态库）

*缺点：*

1.消耗系统资源，浪费内存（在链接时将代码加载到内存中，因此每有一个使用该静态库的接口就会加载一次该静态库）

2.更新、部署、发布麻烦（当更新静态库中的函数时，需要重新将静态库打包给使用者并重新编译链接，或由发布者重新编译链接为可执行程序再发给使用者）

**动态库**：

*优点：*

1.可以实现进程间资源共享（只要有一个程序使用了该动态库，那么该动态库就会被动态加载到内存中，其他程序使用该动态库时可以直接使用，不需要重新加载）

2.更新、部署、发布简单（更新时只需要将原来位置的动态库替换为新的动态库即可，程序在运行时才会动态加载动态库）

3.可以控制何时加载动态库

*缺点*：

1.加载速度比静态库慢（因为多了一个动态加载即寻找动态库的过程）

2.发布程序时需提供依赖的动态库
